\chapter{Introduction}

\section{Motivation \& Goal}
Distributed constraint optimization allows to solve a broad category of problems where multiple agents are involved and a global utility function needs to be optimized. Problems range from graph coloring \cite{Modi2005} to task allocation and scheduling \cite{Zhang}, traffic congestion management \cite{Leeuwen2002} or to disaster recovery \cite{J1999}. The distributed variant of constraint optimization has been extensively adressed by researchers and numerous algorithms with varying design approaches have been proposed. However, these algorithms were often designed based on the premise that problems are static in their predefined state and do not change over the course of the problem solving process. A form of dynamic changes can be achieved with a step by step procedure, where the problem definition is updated after each step, but such a protocol does not work in a distributed manner with multiple involved agents \cite{Petcua}. Many distributed problems have dynamic properties and in a world with ever-increasing complexity and speed, those become continually more relevant for real-world applications. Constraints can change, but also the involved variables as well as the problem domain itself. Imagine for example an optimization software of a global logistics company where vehicles can get damaged and orders could be changed to other adresses or even canceled. A recalculation of the complete problem set with a new  static definition seems inefficient. Research in dynamic distributed constraint optimization has started to gain momentum. The benchmarking of distributed constraint optimization  algorithms with changing problem definitions currently lacks a solid theoretical foundation, but researchers have started to develop benchmarking protocols that aim to standardize the process \cite{Maillera}. 
\newline \newline
This thesis tries to explore dynamic distributed constraint optimization by implementing a complete and two local-iterative variations of algorithm approaches and compare their performance in a dynamic environment. The complete algorithm acts as a baseline and the main focus is on the performance of the local-iterative types of algorithms. They do not guarantee complete solutions but are able to provide a good solution in a faster way as they calculate utilities on a local level with a lower communication overhead. They also have been proven to be more scalable because of this lack of organizational overhead \cite{Chapman2011}. These attributes indicate their potential ability to adapt faster to problem changes and keep a better stability. The main focus lays on the abilities of the MaxSum algorithm, which is a local-iterative message-passing algorithm. It is further a goal to show ways of benchmarking these type of problems from various aspects. The real-world use case for the thesis will be meeting scheduling and the software will be implemented with the Signal/Collect framework, a graph processing engine developed at  the Dynamic and Distributed System Group at the Departement of Informatics of the University of Zurich.
\newline \newline
The implemented software is made available online under the Apache license version 2.0.\footnote{https://github.com/danihegglin/DynDCO}\footnote{http://www.apache.org/licenses/LICENSE-2.0}

% should include the statement from the beginning

\section{Structure}
First, an overview will be given about various definitions and aspects of constraint optimization in general, as well as the aspects of  the distributed and dynamic variations. Further, an examination will be provided about different approaches of algorithms to solve constraint optimization problems and their advantages and disadvantages in context of solution quality over time, scalability and adaptability to changes. 

Secondly, the meeting scheduling problem definition and the mapping to a distributed constraint optimization problem, as well as the algorithm mapping to the Signal/Collect programming model will be detailed in the design chapter. Further, the design considerations for a framework for dynamic changes will be explained and the solution for data collection will also be briefly introduced.

Finally, the performed benchmarks will be evaluated and discussed. In a first series, the algorithms will be tested in static environments to evaluate the implementation. In a second series, various tests on changing constraints, variables and the domain with different rates and different problem densities will be run to determine the performance of the algorithms in dynamic environments. To wrap up, further work possibilities and limitations of the thesis will be pointed out and a conclusion about the achieved contributions and results will be given.